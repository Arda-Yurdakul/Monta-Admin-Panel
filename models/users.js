// This model was generated by Lumber. However, you remain in control of your models.
// Learn how here: https://docs.forestadmin.com/documentation/v/v6/reference-guide/models/enrich-your-models
module.exports = (sequelize, DataTypes) => {
  const { Sequelize } = sequelize;
  // This section contains the fields of your model, mapped to your table's columns.
  // Learn more here: https://docs.forestadmin.com/documentation/v/v6/reference-guide/models/enrich-your-models#declaring-a-new-field-in-a-model
  const Users = sequelize.define('users', {
    pushAlias: {
      type: DataTypes.STRING,
      field: 'push_alias',
      allowNull: false,
    },
    identifier: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    referral: {
      type: DataTypes.STRING,
    },
    firstName: {
      type: DataTypes.STRING,
      field: 'first_name',
    },
    lastName: {
      type: DataTypes.STRING,
      field: 'last_name',
    },
    email: {
      type: DataTypes.STRING,
    },
    phone: {
      type: DataTypes.STRING,
    },
    emailVerifiedAt: {
      type: DataTypes.DATE,
      field: 'email_verified_at',
    },
    phoneVerifiedAt: {
      type: DataTypes.DATE,
      field: 'phone_verified_at',
    },
    password: {
      type: DataTypes.STRING,
    },
    role: {
      type: DataTypes.ENUM('guest','user','admin','super-admin'),
      defaultValue: "guest",
      allowNull: false,
    },
    languages: {
      type: DataTypes.JSON,
    },
    language: {
      type: DataTypes.STRING,
    },
    address1: {
      type: DataTypes.STRING,
    },
    address2: {
      type: DataTypes.STRING,
    },
    address3: {
      type: DataTypes.STRING,
    },
    city: {
      type: DataTypes.STRING,
    },
    zip: {
      type: DataTypes.STRING,
    },
    blockedAt: {
      type: DataTypes.DATE,
      field: 'blocked_at',
    },
    hasBetaAccess: {
      type: DataTypes.INTEGER,
      field: 'has_beta_access',
      defaultValue: 0,
      allowNull: false,
    },
    profileImageManualPath: {
      type: DataTypes.STRING,
      field: 'profile_image_manual_path',
    },
    profileImageAvatarPath: {
      type: DataTypes.STRING,
      field: 'profile_image_avatar_path',
    },
    profileImageSocialUrl: {
      type: DataTypes.STRING,
      field: 'profile_image_social_url',
    },
    profileImageUsed: {
      type: DataTypes.ENUM('manual','avatar','social'),
      field: 'profile_image_used',
      defaultValue: "avatar",
      allowNull: false,
    },
    settingPriorityPrice: {
      type: DataTypes.INTEGER,
      field: 'setting_priority_price',
      defaultValue: 0,
      allowNull: false,
    },
    settingPriorityCo2: {
      type: DataTypes.INTEGER,
      field: 'setting_priority_co2',
      defaultValue: 0,
      allowNull: false,
    },
    settingPriorityRenewable: {
      type: DataTypes.INTEGER,
      field: 'setting_priority_renewable',
      defaultValue: 0,
      allowNull: false,
    },
    chargeCount: {
      type: DataTypes.INTEGER,
      field: 'charge_count',
      defaultValue: 0,
      allowNull: false,
    },
    deletedAt: {
      type: DataTypes.DATE,
      field: 'deleted_at',
    },
    rememberToken: {
      type: DataTypes.STRING,
      field: 'remember_token',
    },
    stripeCustomerId: {
      type: DataTypes.STRING,
      field: 'stripe_customer_id',
    },
    authProviderCount: {
      type: DataTypes.INTEGER,
      field: 'auth_provider_count',
      defaultValue: 0,
      allowNull: false,
    },
    termsReadAt: {
      type: DataTypes.DATE,
      field: 'terms_read_at',
    },
    countrySetAt: {
      type: DataTypes.DATE,
      field: 'country_set_at',
    },
    defaultPickupAt: {
      type: DataTypes.TIME,
      field: 'default_pickup_at',
    },
    acceptProductEmailsAt: {
      type: DataTypes.DATE,
      field: 'accept_product_emails_at',
    },
    acceptMarketingEmailsAt: {
      type: DataTypes.DATE,
      field: 'accept_marketing_emails_at',
    },
    autoReceiptsAt: {
      type: DataTypes.DATE,
      field: 'auto_receipts_at',
      defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
    },
    rateApp: {
      type: DataTypes.ENUM('wait','now','done'),
      field: 'rate_app',
      defaultValue: "wait",
      allowNull: false,
    },
    intercomId: {
      type: DataTypes.STRING,
      field: 'intercom_id',
    },
    createdAt: {
      type: DataTypes.DATE,
      field: 'created_at',
    },
    updatedAt: {
      type: DataTypes.DATE,
      field: 'updated_at',
    },
  }, {
    tableName: 'users',
  });

  // This section contains the relationships for this model. See: https://docs.forestadmin.com/documentation/v/v6/reference-guide/relationships#adding-relationships.
  Users.associate = (models) => {
    Users.belongsTo(models.countryAreas, {
      foreignKey: {
        name: 'countryAreaIdKey',
        field: 'country_area_id',
      },
      as: 'countryArea',
    });
    Users.belongsTo(models.countries, {
      foreignKey: {
        name: 'countryIdKey',
        field: 'country_id',
      },
      as: 'country',
    });
    Users.belongsToMany(models.users, {
      through: 'userReferrals',
      foreignKey: 'from_user_id',
      otherKey: 'to_user_id',
      as: 'usersThroughUserReferrals',
    });
    Users.belongsToMany(models.users, {
      through: 'userReferrals',
      foreignKey: 'to_user_id',
      otherKey: 'from_user_id',
      as: 'usersThroughUserReferralsToUserId',
    });
    Users.belongsToMany(models.vehicles, {
      through: 'userVehicle',
      foreignKey: 'user_id',
      otherKey: 'vehicle_id',
      as: 'vehiclesThroughUserVehicles',
    });
    Users.hasMany(models.bankAccounts, {
      foreignKey: {
        name: 'approvedByUserIdKey',
        field: 'approved_by_user_id',
      },
      as: 'approvedByUserBankAccounts',
    });
    Users.hasMany(models.chargePointAuthTokens, {
      foreignKey: {
        name: 'userIdKey',
        field: 'user_id',
      },
      as: 'chargePointAuthTokens',
    });
    Users.hasMany(models.chargePointReadings, {
      foreignKey: {
        name: 'approvedByUserIdKey',
        field: 'approved_by_user_id',
      },
      as: 'approvedByUserChargePointReadings',
    });
    Users.hasMany(models.chargePointReadings, {
      foreignKey: {
        name: 'declinedByUserIdKey',
        field: 'declined_by_user_id',
      },
      as: 'declinedByUserChargePointReadings',
    });
    Users.hasMany(models.chargePointReadings, {
      foreignKey: {
        name: 'userIdKey',
        field: 'user_id',
      },
      as: 'chargePointReadings',
    });
    Users.hasMany(models.chargePointSuggestions, {
      foreignKey: {
        name: 'userIdKey',
        field: 'user_id',
      },
      as: 'chargePointSuggestions',
    });
    Users.hasMany(models.chargePoints, {
      foreignKey: {
        name: 'userIdKey',
        field: 'user_id',
      },
      as: 'chargePoints',
    });
    Users.hasMany(models.charges, {
      foreignKey: {
        name: 'userIdKey',
        field: 'user_id',
      },
      as: 'charges',
    });
    Users.hasMany(models.chatUser, {
      foreignKey: {
        name: 'userIdKey',
        field: 'user_id',
      },
      as: 'chatUsers',
    });
    Users.hasMany(models.chats, {
      foreignKey: {
        name: 'blockedByUserIdKey',
        field: 'blocked_by_user_id',
      },
      as: 'blockedByUserChats',
    });
    Users.hasMany(models.deeplinkPayloads, {
      foreignKey: {
        name: 'userIdKey',
        field: 'user_id',
      },
      as: 'deeplinkPayloads',
    });
    Users.hasMany(models.devices, {
      foreignKey: {
        name: 'userIdKey',
        field: 'user_id',
      },
      as: 'devices',
    });
    Users.hasMany(models.favorites, {
      foreignKey: {
        name: 'userIdKey',
        field: 'user_id',
      },
      as: 'favorites',
    });
    Users.hasMany(models.invoices, {
      foreignKey: {
        name: 'approvedByUserIdKey',
        field: 'approved_by_user_id',
      },
      as: 'approvedByUserInvoices',
    });
    Users.hasMany(models.partnerSuggestions, {
      foreignKey: {
        name: 'acceptedByUserIdKey',
        field: 'accepted_by_user_id',
      },
      as: 'acceptedByUserPartnerSuggestions',
    });
    Users.hasMany(models.partnerSuggestions, {
      foreignKey: {
        name: 'createdByUserIdKey',
        field: 'created_by_user_id',
      },
      as: 'createdByUserPartnerSuggestions',
    });
    Users.hasMany(models.partnerUser, {
      foreignKey: {
        name: 'userIdKey',
        field: 'user_id',
      },
      as: 'partnerUsers',
    });
    Users.hasMany(models.plans, {
      foreignKey: {
        name: 'approvedByUserIdKey',
        field: 'approved_by_user_id',
      },
      as: 'approvedByUserPlans',
    });
    Users.hasMany(models.ratings, {
      foreignKey: {
        name: 'userIdKey',
        field: 'user_id',
      },
      as: 'ratings',
    });
    Users.hasMany(models.reports, {
      foreignKey: {
        name: 'userIdKey',
        field: 'user_id',
      },
      as: 'reports',
    });
    Users.hasMany(models.subscriptions, {
      foreignKey: {
        name: 'cancelledByUserIdKey',
        field: 'cancelled_by_user_id',
      },
      as: 'cancelledByUserSubscriptions',
    });
    Users.hasMany(models.subscriptions, {
      foreignKey: {
        name: 'purchasedByUserIdKey',
        field: 'purchased_by_user_id',
      },
      as: 'purchasedByUserSubscriptions',
    });
    Users.hasMany(models.teamMembers, {
      foreignKey: {
        name: 'userIdKey',
        field: 'user_id',
      },
      as: 'teamMembers',
    });
    Users.hasMany(models.teamMembers, {
      foreignKey: {
        name: 'acceptedByUserIdKey',
        field: 'accepted_by_user_id',
      },
      as: 'acceptedByUserTeamMembers',
    });
    Users.hasMany(models.teamMembers, {
      foreignKey: {
        name: 'blockedByUserIdKey',
        field: 'blocked_by_user_id',
      },
      as: 'blockedByUserTeamMembers',
    });
    Users.hasMany(models.teamMembers, {
      foreignKey: {
        name: 'invitedByUserIdKey',
        field: 'invited_by_user_id',
      },
      as: 'invitedByUserTeamMembers',
    });
    Users.hasMany(models.teams, {
      foreignKey: {
        name: 'userIdKey',
        field: 'user_id',
      },
      as: 'teams',
    });
    Users.hasMany(models.userAuthProviders, {
      foreignKey: {
        name: 'userIdKey',
        field: 'user_id',
      },
      as: 'userAuthProviders',
    });
    Users.hasMany(models.userDataRequests, {
      foreignKey: {
        name: 'performedByUserIdKey',
        field: 'performed_by_user_id',
      },
      as: 'performedByUserUserDataRequests',
    });
    Users.hasMany(models.userDataRequests, {
      foreignKey: {
        name: 'userIdKey',
        field: 'user_id',
      },
      as: 'userDataRequests',
    });
    Users.hasMany(models.userDeleteRequests, {
      foreignKey: {
        name: 'performedByUserIdKey',
        field: 'performed_by_user_id',
      },
      as: 'performedByUserUserDeleteRequests',
    });
    Users.hasMany(models.userDeleteRequests, {
      foreignKey: {
        name: 'userIdKey',
        field: 'user_id',
      },
      as: 'userDeleteRequests',
    });
    Users.hasMany(models.userEmailVerifications, {
      foreignKey: {
        name: 'userIdKey',
        field: 'user_id',
      },
      as: 'userEmailVerifications',
    });
    Users.hasMany(models.userPhoneVerifications, {
      foreignKey: {
        name: 'userIdKey',
        field: 'user_id',
      },
      as: 'userPhoneVerifications',
    });
    Users.hasMany(models.userResetPasswordEmails, {
      foreignKey: {
        name: 'userIdKey',
        field: 'user_id',
      },
      as: 'userResetPasswordEmails',
    });
  };

  return Users;
};
